========
Overview
========

Let's dig into why meta-programming function signatures is a good idea, and then we'll cover some principals.


**The why**: intuitive design
=============================

Without restoring to :func:`exec`, Python lacks the ability to dynamically implement function signatures.
And, with :func:`exec`, no one wants to play with you (for good reason).

Consider the following scenario, where :func:`do_aliens_exist` is wrapped and simplified.

  .. code-block:: python

    >>> def do_aliens_exist(ts, lat, lon, p1, p2, p3, p4, p5):
    ...     '''
    ...     takes the time, our location, and 5 parameters
    ...     returns: whether aliens exist
    ...     '''
    ...     compute(...)
    ...
    >>> def do_aliens_exist_easy(**kwargs):
    ...     '''an easier way to determine if aliens exist'''
    ...     defaults = dict(
    ...         p1='a', p2='b', p3='c', p4='d', p5='e',
    ...         ts=datetime.now(), lat='-0.8292', lon='-91.1353',
    ...     )
    ...     cleaned = {k: kwargs.get(k, v) for k, v in defaults.items()}
    ...     return do_aliens_exist(**cleaned)
    ...
    >>> do_aliens_exist_easy(p1='x')
    True

Writing, testing and maintaining signature parity is a lot of work, and even when it's important – like when determining whether aliens exist – authors are remiss to put in the effort.

Instead, we ask for the :term:`var-keyword` parameter ``**kwargs``, white-listing certain variables and ignoring others.
There is method to the madness, but the consumers of our code are left in the dark, asking "what parameters are accepted; what should I pass?".

Too fanciful?
How about a real world example: the stdlib :mod:`logging` module.
When inspecting one of the seven logging methods (i.e. :func:`debug`, :func:`info`, :func:`warning`, :func:`error`, :func:`critical`, :func:`log`, and :func:`exception`) we get a meaningless signature:

.. code-block:: python

  >>> import logging
  >>> help(logging.debug)
  Help on function debug in module logging:

  debug(msg, *args, **kwargs)
      Log a message with severity 'DEBUG' on the root logger. If the logger has no handlers, call basicConfig() to add a console handler with a pre-defined format.

  >>> exc = ValueError('divided by zero')
  >>> logging.error('Got a {err_type} exception', err_type=type(exc).__name__)
  TypeError: _log() got an unexpected keyword argument 'err_type'
  >>> # Huh, figured those kwargs were for string formatting

The current signature is worse than useless for consumers of the function – at best additional functionality is left unused, hidden behind the :term:`var-positional` parameter `*args`` and the :term:`var-keyword` parameter ``**kwargs``.
At worst, consumers infer functionality that might be wrong.

Let's look up the ``stdlib``'s `logging module documentation`_ for :func:`logging.debug` (where :func:`logging.error` redirects us):

  ``logging.debug(msg, *args, **kwargs)``

  Logs a message with level DEBUG on the root logger.
  The **msg** is the message format string, and the **args** are the arguments which are merged into msg using the string formatting operator.
  (Note that this means that you can use keywords in the format string, together with a single dictionary argument.)

  There are three keyword arguments in kwargs which are inspected: **exc_info** which, if it does not evaluate as false, causes exception information to be added to the logging message.
  If an exception tuple (in the format returned by sys.exc_info()) is provided, it is used; otherwise, sys.exc_info() is called to get the exception information.

  The second optional keyword argument is **stack_info**, which defaults to False.
  If true, stack information is added to the logging message, including the actual logging call.
  Note that this is not the same stack information as that displayed through specifying exc_info: The former is stack frames from the bottom of the stack up to the logging call in the current thread, whereas the latter is information about stack frames which have been unwound, following an exception, while searching for exception handlers.

  You can specify stack_info independently of exc_info, e.g. to just show how you got to a certain point in your code, even when no exceptions were raised.
  The stack frames are printed following a header line which says:

  ...

  The third optional keyword argument is **extra** which can be used to pass a dictionary which is used to populate the __dict__ of the LogRecord created for the logging event with user-defined attributes.
  These custom attributes can then be used as you like.
  For example, they could be incorporated into logged messages. For example:

  ...

That's a lot of documentation, but it uncovers why our attempt at supplying keyword arguments raises an :class:`Exception`. We wrongly inferred functionality like that provided by :func:`str.format` provides.
But, let's have some empathy; the Python core developers don't want to repeat themselves seven times, right?


**The how**: magic-free manipulation
====================================

Modern Python (3.5+) advertises a ``callable`` signature by looking for:

#. a :attr:`__signature__` attribute on your callable
#. devising a signature from the :attr:`__code__` attribute of the callable

And it allows for `type-hints`_ on parameters and return-values by looking for:

#. an :attr:`__annotations__` attribute on the callable with a ``return`` key
#. devising a signature from the :attr:`__code__` attribute of the callable

When you call a function wrapped with ``forge``, the following occurs:

#. **arguments** are associated with the public-facing parameters
#. pre-**bound** parameters are added to the arguments mapping
#. **default** values are applied for missing parameters
#. **converters** (as supplied) are applied to the default or provided values
#. **validators** (as supplied) are called with the converted values
#. the arguments are mapped onto the wrapped function's signature
#. the wrapped function is called with the mapped attributes


**The what**: applying the knowledge
====================================

Looking back on the code for :func:`logging.debug`, let's try and improve upon this implementation by wrapping the standard logging methods with enough information to provide basic direction for end-users.

.. code-block:: python

  >>> make_explicit = forge.sign(
  ...     forge.arg('msg'),
  ...     *forge.args('substitutions'),
  ...     exc_info=forge.kwarg(default=False),
  ...     stack_info=forge.kwarg(default=False),
  ...     extras=forge.kwarg(factory=dict),
  ... )
  >>> debug = make_explicit(logging.debug)
  >>> info = make_explicit(logging.info)
  >>> warning = make_explicit(logging.warning)
  >>> error = make_explicit(logging.error)
  >>> critical = make_explicit(logging.critical)
  >>> log = make_explicit(logging.log)
  >>> exception = make_explicit(logging.exception)

The seven logging methods of :mod:`logging` have been wrapped.
Let's see what it actually looks like:

.. code-block:: python

  >>> help(debug)
  Help on function debug in module logging:

  debug(msg, *substitutions, exc_info=False, stack_info=False, extras=<Factory dict>)
     Log a message with severity 'DEBUG' on the root logger. If the logger has
     no handlers, call basicConfig() to add a console handler with a pre-defined
     format.
  >>> exc = ValueError('divided by zero')
  >>> logging.error('Got a %s exception', type(exc).__name__)
  ERROR:root:Got a ValueError exception

We now have an aided intuition about how to use the function.

Forge provides a sane middle-ground for *well-intentioned, albeit lazy* package authors and *pragmatic, albeit lazy* package consumers to communicate functionality and intent.

**The bottom-line**: everyone deserves better
---------------------------------------------
After a case-study with :mod:`logging` where we enhanced the code with context, let's consider the modern state of Python signatures beyond the ``stdlib``.

Codebases you the broadly adopted :mod:`sqlalchemy` or :mod:`graphene` could benefit, as could third party corporate APIs which expect you to identify subtleties.

Driving developers from their IDE to your documentation is an dark pattern. Be a good community member – write cleanly and clearly.

.. _principals:

Design principals
=================

**The API emulates usage.**
  ``forge`` provides an API for making function signatures more literate.
  Therefore, the library is designed in a literate way.
  Users are encouraged to supply :term:`positional-only` and :term:`positional-or-keyword` parameters as positional arguments, the :term:`var-positional` parameter for positional-expansion (e.g. ``*forge.args``), :term:`keyword-only` parameters as keyword arguments, and the :term:`var-keyword` parameter for keyword expansion (e.g. ``**forge.kwargs``).

**Minimal API impact.**
  Your callable, and it's underlying code is 100% unmodified, organic.
  You can even get the original function by accessing the function's :attr:`__wrapped__` attribute.

  Function in, function out: no hybrid instance-callables produced.
  :func:`classmethod``, :func:`staticmethod``, and :func:`property`` are all supported.

**Performance matters.**
  ``forge`` was written from the ground up with an eye on performance, so it does the heavy lifting once, upfront rather than every time it's called.

  All classes use :attr:`__slots__` for speeder attribute access.
  PyPy 6.0.0+ has first class support.

**Immutable and flexible.**
  ``forge`` classes are immutable, but also flexible enough to support dynamic usage.
  You can share an :class:`FParameter` or :class:`FSignature` without fearing for your previously signed classes.

**Type-Hints available.**
  ``forge`` supports the use of `type-hints`_ by providing an API for supplying types on parameters.
  In addition, ``forge`` itself is written with `type-hints`_.

**100% Coverage and Linted**
  ``forge`` maintains 100% code-coverage through unit testing.
  Code is also linted with ``mypy`` and ``pylint`` during automated testing upon every ``git push``.


What ``forge`` is not
=====================

``forge`` isn't an interface to the wild-west that is :func:`exec` or :func:`eval`.

All ``forge`` does is:

1. takes your new signature,
2. wraps your old callable,
3. routes calls between the two

The mapper is built prior to execution (for speed).
It's available for inspection, but immutable (at :attr:`__mapper__``).
The callable remains unmodified and intact (at :attr:``__wrapped__``).


Common names: ``forge.arg`` and ``forge.kwarg``
===============================================

Based on a quick, informal poll of ``#python``, many developers don't know the formal parameter names. Given a function that looks like:

.. doctest::

  >>> def func(a, b=3, *args, c=3, **kwargs):
  ...     pass

- ``a`` is often referred to as an *argument* (an ``arg``), and
- ``c`` is often referred to as a *keyword argument* (a ``kwarg``),
- ``b`` is usually bucketed as either of the above,
- ``*args`` is simply referred to as ``args``, and
- ``**kwargs`` is simply referred to as ``kwargs``.

Officially, that's inaccurate.
- ``a`` and ``b`` are :term:`positional-or-keyword` parameters,
- ``c`` is a :term:`keyword-only` parameter,
- ``args`` is a :term:`var-positional` parameter, and
- ``kwargs`` is a :term:`var-keyword` parameter.

Python developers are often pragmatic developers, so ``forge`` was written in a supportive manner.
Therefore, the following synonyms are defined:

- creation of :term:`positional-only` parameters with :func:`forge.pos`,
- creation of :term:`positional-or-keyword` parameters with :func:`forge.arg` or :func:`forge.pok`, and
- creation of :term:`keyword-only` parameters with :func:`forge.kwarg` or :func:`forge.kwo`.

Use whichever variant you please.

.. _`logging module documentation`: https://docs.python.org/3.6/library/logging.html#logging.debug
.. _`type-hints`: https://docs.python.org/3/library/typing.html