========
Overview
========

Let's dig into why meta-programming function signatures is a good idea,
and then we'll cover some principals.


**The why**: intuitive design
=============================

Without restoring to ``exec``,
Python lacks the ability to dynamically implement function signatures.
And, with ``exec``, no one wants to play with you (for good reason).

Consider the following scenario,
where ``do_aliens_exist`` is wrapped and simplified.

  .. code-block:: python

    >>> def do_aliens_exist(ts, lat, lon, p1, p2, p3, p4, p5):
    ...     '''
    ...     takes the time, our location, and 5 parameters
    ...     returns: whether aliens exist
    ...     '''
    ...     compute(...)
    ...
    >>> def do_aliens_exist_easy(**kwargs):
    ...     '''an easier way to determine if aliens exist'''
    ...     defaults = dict(
    ...         p1='a', p2='b', p3='c', p4='d', p5='e',
    ...         ts=datetime.now(), lat='-0.8292', lon='-91.1353',
    ...     )
    ...     cleaned = {k: kwargs.get(k, v) for k, v in defaults.items()}
    ...     return do_aliens_exist(**cleaned)
    ...
    >>> do_aliens_exist_easy(p1='x')
    True

Writing, testing and maintaining signature parity is a lot of work,
and even when it's important –
like when determining whether aliens exist –
authors are remiss to put in the effort.

Instead, we ask for the var-keyword argument ``**kwargs``,
white-listing certain variables and ignoring others.
There is method to the madness,
but the consumers of our code are left in the dark,
asking "what parameters are accepted; what should I pass?".

Too fanciful?
How about a real world example: the stdlib ``logging`` module.
When inspecting one of the seven logging methods
(i.e. ``debug``, ``info``, ``warning``, ``error``, etc.)
we get a meaningless signature:

.. code-block:: python

  >>> import logging
  >>> help(logging.debug)
  Help on function debug in module logging:

  debug(msg, *args, **kwargs)
      Log a message with severity 'DEBUG' on the root logger. If the logger has
      no handlers, call basicConfig() to add a console handler with a pre-defined
      format.

  >>> exc = ValueError('divided by zero')
  >>> logging.error('Got a {err_type} exception', err_type=type(exc).__name__)
  TypeError: _log() got an unexpected keyword argument 'err_type'
  >>> # Huh, figured those kwargs were for string formatting

The current signature is worse than useless for consumers of the function – 
at best additional functionality is left unused,
hidden behind ``*args`` and ``**kwargs``.
But at worst, consumers presume functionality that might be missing.

Let's look up the `documentation <https://docs.python.org/3.6/library/logging.html#logging.debug>`_
for ``logging.debug``
(where ``logging.error`` redirects us):

  ``logging.debug(msg, *args, **kwargs)``

  Logs a message with level DEBUG on the root logger.
  The **msg** is the message format string,
  and the **args** are the arguments which are merged into msg
  using the string formatting operator.
  (Note that this means that you can use keywords in the format string,
  together with a single dictionary argument.)

  There are three keyword arguments in kwargs which are inspected:
  **exc_info** which, if it does not evaluate as false,
  causes exception information to be added to the logging message.
  If an exception tuple (in the format returned by sys.exc_info()) is provided,
  it is used; otherwise, sys.exc_info() is called to get the exception information.

  The second optional keyword argument is **stack_info**,
  which defaults to False. If true,
  stack information is added to the logging message,
  including the actual logging call.
  Note that this is not the same stack information
  as that displayed through specifying exc_info:
  The former is stack frames from the bottom of the stack
  up to the logging call in the current thread,
  whereas the latter is information about stack frames which have been unwound,
  following an exception, while searching for exception handlers.

  You can specify stack_info independently of exc_info,
  e.g. to just show how you got to a certain point in your code,
  even when no exceptions were raised.
  The stack frames are printed following a header line which says:

  ...

  The third optional keyword argument is **extra**
  which can be used to pass a dictionary
  which is used to populate the __dict__ of the LogRecord
  created for the logging event with user-defined attributes.
  These custom attributes can then be used as you like.
  For example, they could be incorporated into logged messages. For example:

  ...

That's a lot of documentation,
but it uncovers why our attempt at supplying keyword arguments –
expecting functionality like ``str.format`` provides –
throws an error.
But, let's have some empathy;
the Python core developers don't want to repeat themselves seven times, right?


**The how**: magic-free manipulation
====================================

Modern Python (3.5+) advertises a ``callable`` signature by looking for:

#. a ``__signature__`` attribute on your callable
#. devising a signature from the ``__code__`` attribute of the callable

And it determines the return-value
(modern Python supports `type-hints <https://docs.python.org/3/library/typing.html>`_, remember?)
by looking for:

#. an ``__annotations__`` attribute on the callable with a ``return`` key
#. devising a signature from the ``__code__`` attribute of the callable

``forge`` works by wrapping your function,
performing a series of transforms on the provided arguments,
and then calling the wrapped function with mapped arguments.

When you call your function who's signature has been forged,
the following occurs:

#. **arguments** are associated with the public-facing parameters
#. pre-**bound** parameters are added to the arguments mapping
#. **default** values are applied for missing parameters
#. **converters** (as supplied) are applied to the default or provided values
#. **validators** (as supplied) are called with the converted values
#. the arguments are mapped onto the wrapped function's signature
#. the wrapped signature is called with the mapped attributes


**The what**: applying the knowledge
====================================

Looking back on the code for ``logging.debug``,
let's try and improve upon this implementation.
We'll write signatures that provide enough basic information
and inform basic usage that won't throw an exception.

.. code-block:: python

  >>> make_explicit = forge.sign(
  ...     forge.arg('msg'),
  ...     *forge.args('substitutions'),
  ...     exc_info=forge.kwarg(default=False),
  ...     stack_info=forge.kwarg(default=False),
  ...     extras=forge.kwarg(factory=dict),
  ... )
  >>> debug = make_explicit(logging.debug)
  >>> info = make_explicit(logging.info)
  >>> warning = make_explicit(logging.warning)
  >>> error = make_explicit(logging.error)
  >>> critical = make_explicit(logging.critical)
  >>> log = make_explicit(logging.log)
  >>> exception = make_explicit(logging.exception)

The seven logging methods of :mod:`logging` have been wrapped.
let's see what it actually looks like:

.. code-block:: python

  >>> help(debug)
  Help on function debug in module logging:

  debug(msg, *substitutions, exc_info=False, stack_info=False, extras=<Factory dict>)
     Log a message with severity 'DEBUG' on the root logger. If the logger has
     no handlers, call basicConfig() to add a console handler with a pre-defined
     format.
  >>> exc = ValueError('divided by zero')
  >>> logging.error('Got a %s exception', type(exc).__name__)
  ERROR:root:Got a ValueError exception

We now have an aided intuition about how to use the function.

Forge provides a sane middle-ground for
well-intentioned, albeit lazy package authors and
pragmatic, albeit lazy package consumers
to share code.

**The truth**: you deserve better
---------------------------------
After a case-study with :mod:`logging` where we enhanced the code with context,
let's consider the modern state of Python signatures beyond the ``stdlib``.

Codebases you the broadly adopted ``sqlalchemy`` or ``graphene`` could benefit,
as could third party corporate APIs which expect you to identify subtleties.

Driving developers from their IDE to your documentation is an dark pattern.
Be a good community member – write cleanly and clearly.

.. _principals:

Design principals
=================

**The API emulates usage.**
  ``forge`` is a tool for revising and re-introducing functions.
  Therefore, the API reflects usage.
  Users are encouraged to supply
  *positional-only* and *positional-or-keyword* parameters as positional arguments,
  the *var-positional* parameter as an unpackaged argument (e.g. ``*forge.args``),
  *keyword-only* parameters as keyword arguments,
  and the *var-keyword* parameter as an unpackaged argument (e.g. ``**forge.kwargs``).

**Minimal API impact.**
  Your callable, and it's underlying code is 100% unmodified, organic.
  You can even get the original function by accessing the function's ``__wrapped__`` attribute.

  Function in, function out: no hybrid instance-callables produced.
  ``@classmethod``, ``@staticmethod``, and ``@property`` are all supported.

**Performance matters.**
  ``forge`` was written from the ground up with an eye on performance,
  so it does the heavy lifting once, upfront
  rather than every time it's called.

  All classes use ``__slots__`` for speeder attribute access.
  PyPy 6.0.0+ has 1st class support.

**Immutable and flexible.**
  ``forge`` classes are immutable,
  but also flexible enough to support dynamic usage.
  You can share an ``FParameter`` or ``FSignature``
  without fearing for your previously signed classes.

**Type-Hints available.**
  ``forge`` supports the use of *type-hints*
  by providing an API for supplying types on parameters.
  In addition, ``forge`` itself is written with type-hints.

**100% Coverage and Linted**
  You shouldn't rely on a package as central as ``forge``
  without demanding 100% unit test coverage.

  Code is also linted with ``mypy`` and ``pylint`` during automated testing.


What ``forge`` is not
=====================

``forge`` isn't an interface to the wild-west that is ``exec`` or ``eval``.

All ``forge`` does is:

1. takes your new signature,
2. wraps your old callable,
3. routes calls between the two

The mapper is built prior to execution (for speed).
It's available for inspection, but immutable (at `__mapper__`).
The callable remains unmodified and intact (at `__wrapped__`).


Common names: ``forge.arg`` and ``forge.kwarg``
===============================================

Many developers haven't internalized the full vocabulary of the Python runtime,
and that's OK.

.. doctest::

  >>> def func(a, b=3, *args, c=3, **kwargs):
  ...     pass

``a`` is often referred to as an *argument* (an ``arg``), and
``c`` is often referred to as a *keyword argument* (a ``kwarg``).
``b`` is usually bucketed as either of the above.

But that's not accurate.
``a`` and ``b`` are *positional-or-keyword* parameters, and
``c`` is a *keyword-only* parameter.
Python developers often talk about the *function* of their code,
rather than it's *interface*.
It's ingrained in our culture as evidenced by naming
the *var-positional* parameter ``*args`` and
the *var-keyword* parameter ``**kwargs``.

``Forge`` embrances this mindset and allows for:

- creation of *positional-only* parameters
  with ``forge.pos(...)``,
- creation of *positional-or-keyword* parameters
  with ``forge.arg(...)`` or ``forge.pok()``, and
- creation of *keyword-only* parameters
  with ``forge.kwarg(...)`` or ``forge.kwo()``.

Use whichever variant you please.